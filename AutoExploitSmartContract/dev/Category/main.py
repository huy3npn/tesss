import os, json
from web3 import Web3
from solcx import compile_source

Provider = 'http://127.0.0.1:8545'
w3 = Web3(Web3.HTTPProvider(Provider))


dataset = os.listdir('./contracts')


groups = {
    1: [],
    2: [],
    3: [],
    4: [],
    5: []
}

# target = dataset.pop()
target = '1.sol'
abi = bytecode = ast = None

compiled_sol = compile_source(
            open('./contracts/{name}'.format(name=target),'r').read(),
            solc_version="0.4.26",
            output_values=['abi', 'bin', 'ast']
)

for name in compiled_sol.keys():
    abi      = compiled_sol[name]['abi']
    bytecode = compiled_sol[name]['bin']
    ast      = compiled_sol[name]['ast']

open('abi.json','w').write(json.dumps(abi))
open('ast.json','w').write(json.dumps(ast))

contract = w3.eth.contract(abi=abi, bytecode=bytecode)
# print(contract.get())

# def signature(func_name, children): # branch = input.children[].children[].children[0].children
#     args = []
#     for child in children:
#         args += [child['attributes']['type']]
#     return func_name + '(' + ','.join(args) + ')'

def analyze(ast):
    variables = []
    for contract in ast['children']: # input.ast.children[]
        if(contract['attributes']['contractKind'] == 'contract'):
            for function in contract['children']: # input.ast.children[].children[]
                if(function['name'] == 'VariableDeclaration'):
                    variables += function['attributes']['name']

                elif(function['name'] == 'FunctionDefinition' and function['attributes']['name'] != ''):
                    function_name = function['attributes']['name']
                    
                    for component in function['children']:
                        check_payable = function['attributes']['payable']
                        if(component['name'] == 'Block'):
                            check_call1 = "'member_name': 'transfer" in str(component).lower()
                            check_call2 = "'member_name': 'send" in str(component).lower()
                            check_call3 = "'member_name': 'call" in str(component).lower()
                            check_selfdestruct = "selfdestruct" in str(component).lower()

                            if(check_payable and (check_call1 or check_call2 or check_call3)):
                                groups[1] += [function_name]
                                break

                            if(check_call1 or check_call2 or check_call3):
                                groups[2] += [function_name]
                                break
                            
                            if(check_payable):
                                groups[3] += [function_name]
                                break

                            if(check_selfdestruct):
                                groups[4] += [function_name]
                                break

                            groups[5] += [function_name]

analyze(ast)
print(groups)
                    
                    # if('body' in function) and (function['body']):
                    #     if('statements' in function['body']):
                    #         for statement in function['body']['statements']:
                    #             if('expression' in statement):
                    #                 if('leftHandSide' in statement['expression']):
                    #                     if('name' in statement['expression']['leftHandSide']):
                    #                         check_store1 = statement['expression']['leftHandSide']['name'] in variables
                    #                         check_store2 = 'storage' in str(function)
                    #                         if(check_store1 or check_store2):
                    #                             data['store'] += string_add_to
                    #                             print(f'[+] Found store: {string_add_to}')
                    #                             continue



# def init():
#     if not(os.path.exists('./experiment')):
#         os.mkdir('./experiment')
# def clear():

#     path = 'build/contracts'
#     if(os.path.exists(path)):
#         for f in os.listdir(path):
#             os.remove(os.path.join(path, f))

#     path = 'contracts'
#     if(os.path.exists(path)):
#         for f in os.listdir(path):
#             os.remove(os.path.join(path, f))
    
#     path = 'experiment'
#     if(os.path.exists(path)):
#         for f in os.listdir(path):
#             os.remove(os.path.join(path, f))

# def truffle_compile():
#     subprocess.check_output(['truffle', 'compile'], shell=True)
#     # os.system('truffle compile --quite')

# def json2dict(target):
#     json_tree = json.load(open('build/contracts/' + target,'r'))
#     return json_tree

# def copybenchmark(target):
#     shutil.copyfile(f'dataset/{target}', f'contracts/{target}')

# def report():
#     for key in data:
#         data[key] = set(data[key])
#         with open(f'./experiment/{key}', 'a') as writer:
#             for value in data[key]:
#                 writer.write(value + '\n')

#     print('[i] Export Done ...')
#     print(f'[+] Call', len(data['call']))
#     print(f'[+] Payable', len(data['payable']))
#     print(f'[+] Selfdestruct', len(data['selfdestruct']))
#     print(f'[+] Store', len(data['store']))


# if(__name__ == '__main__'):
#     init()
#     while True:
#         try:
#             clear()
#             copybenchmark(target)
#             truffle_compile()
#             artifacts = os.listdir('build/contracts')

#             for artifact in artifacts:
#                 print('[i] Analyzing artifact', artifact)
#                 analyzer(json2dict(artifact))
#                 print('-' * 100)

#             if(len(dataset) > 0) : target = dataset.pop()
#             else: break
#         except Exception as err:
#             print("[X] ERROR", err)
#             if(len(dataset) > 0) :target = dataset.pop()
#             else: break

#     report()


        
        

