import random

class PolicyRandom():

    def __init__(self, contract_manager, accounts_list):
        super().__init__( contract_manager, accounts_list)


    def select_tx_for_method(self, contract, method):
        self.slice_size = random.randint(1, 5)
        address = contract.addresses[0]
        sender = self._select_sender()
        arguments = self._select_arguments(contract, method, sender)
        amount = self._select_amount(contract, method, sender)
        timestamp = self._select_timestamp()

        tx = Tx(self, contract.name, address, method.name, bytes(), arguments, amount, sender, timestamp, True)
        return tx


    def select_tx(self):
        contract = self._select_contract()
        address = contract.addresses[0]
        method = self._select_method(contract)
        sender = self._select_sender()
        arguments = self._select_arguments(contract, method, sender)
        amount = self._select_amount(contract, method, sender)
        timestamp = self._select_timestamp()

        tx = Tx(self, contract.name, address, method.name, bytes(), arguments, amount, sender, timestamp, True)
        return tx


    def _select_contract(self):
        contract_name = random.choice(self.contract_manager.fuzz_contract_names)
        return self.contract_manager[contract_name]


    def _select_method(self, contract):
        return random.choice(contract.abi.methods)


    def _select_sender(self):
        return random.choice(range(0, len(self.account_manager.accounts)))


    def _select_amount(self, contract, method, sender):
        if sender in self.account_manager.attacker_indices:
            return 0

        if self.contract_manager.is_payable(contract.name, method.name):
            amount = random.randint(0, self.account_manager[sender].amount)
            return amount
        else:
            return 0


    def _select_arguments(self, contract, method, sender):
        import re
        arguments = []
        for arg in method.inputs:
            arg_type = arg.type
            if re.match('^int\d+', arg_type):
                arguments.append(self._select_int(contract, method, arg.evm_type.size))
            elif re.match('^uint\d+', arg_type):
                arguments.append(self._select_uint(contract, method, arg.evm_type.size))
            elif re.match('bool', arg_type):
                arguments.append(self._select_bool())
            elif re.match('string', arg_type):
                arguments.append(self._select_string())
            elif re.match('array', arg_type):
                arguments.append(self._select_array(contract, method, sender, arg.evm_type.size, arg.evm_type.elem))
            elif re.match('address', arg_type):
                arguments.append(self._select_address(sender))
            elif t == SolType.FixedBytesTy:
                arguments.append(self._select_fixed_bytes(arg.evm_type.size))
            elif re.match('bytes', arg_type):
                arguments.append(self._select_bytes())
            else:
                assert False, 'type {} not supported'.format(t)
        return arguments


    def _select_int(self, size):
        p = 1 << (size - 1)
        return random.randint(-p, p-1)


    def _select_uint(self, size):
        p = 1 << size
        return random.randint(0, p-1)


    def _select_string(self):
        bs = []
        size = random.randint(0, 40)
        for _ in range(size):
            bs.append(random.randint(1, 127))
        return bytearray(bs).decode('ascii')


    def _select_bool(self):
        return random.choice([True, False])


    def _select_slice(self, contract, method, sender, typ):
        size = random.randint(1, 15)
        return self._select_array(contract, method, sender, size, typ)


    def _select_array(self, contract, method, sender, size):
        t = typ.t
        arr = []
        for _ in range(size):
            if t == SolType.IntTy:
                arr.append(self._select_int(contract, method, typ.size))
            elif t == SolType.UintTy:
                arr.append(self._select_uint(contract, method, typ.size))
            elif t == SolType.BoolTy:
                arr.append(self._select_bool())
            elif t == SolType.StringTy:
                arr.append(self._select_string())
            elif t == SolType.SliceTy:
                arr.append(self._select_slice(contract, method, sender, typ.elem))
            elif t == SolType.ArrayTy:
                arr.append(self._select_array(contract, method, sender, typ.size, typ.elem))
            elif t == SolType.AddressTy:
                arr.append(self._select_address(sender))
            elif t == SolType.FixedBytesTy:
                arr.append(self._select_fixed_bytes(typ.size))
            elif t == SolType.BytesTy:
                arr.append(self._select_bytes())
            else:
                assert False, 'type not supported'

        return arr


    def _select_address(self):
        return random.choice(self.addresses)


    def _select_fixed_bytes(self, size):
        bs = []
        for _ in range(size):
            bs.append(random.randint(0, 255))
        return bs


    def _select_bytes(self):
        size = random.randint(1, 15)
        return self._select_fixed_bytes(size)