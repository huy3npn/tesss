from solcx import compile_source
from collections import OrderedDict, Counter
import random, json
from .method import FunctionRecord
# from .detector import Detector
from .category import Category
from colorama import Fore
# from evm_trace import *  


def debug(*args, color=Fore.MAGENTA):
    print(color + "***************[DEBUG]***************")
    print(color + str(args))

class Contract:
    def __init__(self, abi, bytecode, opcodes, ast):
        self.abi = abi
        self.bytecode = bytecode
        self.ast = ast
        self.opcodes = opcodes
        self.basic_block = [op for op in self.opcodes if op!="JUMPDEST"]
        self.group_functions = Category(abi, ast).groups
        debug(self.group_functions, color=Fore.LIGHTGREEN_EX)
        self.address = None
        self.execution_count  = 0
        self.function_records = OrderedDict()
        self.features = {
                "Trace" :
                {
                    "SHA3": self.opcodes.count("SHA3"),
                    "CALL": self.opcodes.count("CALL"),
                    "CREATE" : self.opcodes.count("CREATE"),
                    "SELFDESTRUCT": self.opcodes.count("SELFDESTRUCT"),
                    "JUMP": self.opcodes.count("JUMP"),
                    "JUMPI": self.opcodes.count("JUMPI"),
                    "SLOAD": self.opcodes.count("SLOAD"),
                    "SSTORE": self.opcodes.count("SSTORE")
                },
                "Coverage" : 0
        }
    
    def calculate_Rblock(self, function):
        F_basic_block  = len(self.function_records[function].basic_block)
        SC_basic_block = len(self.basic_block)
        return round(float(F_basic_block / SC_basic_block), 5)

    def calculate_Rcov(self):
        M = self.group_functions
        N = len(M)
        Rcov_product = 1.0
        for i in range(1,N + 1):
            if(len(M[i]) == 0) : continue
            product = 1.0
            for j in M[i]:
                if(j not in self.function_records): continue
                product += self.calculate_Rblock(j)
            Rcov_product += (1.0 / len(M[i])) * product
        return Rcov_product * (1/N)
    
    def calculate_Rmix(self, alpha, Rbugs):
        Rcov = self.calculate_Rcov()
        return alpha * Rbugs + (1.0 - alpha) * Rcov
            
class ContractManager:
    def __init__(self, w3_provider, accounts):
        self.contracts      = OrderedDict()
        self.solfile        = None
        self.instance       = None
        self.deploy_address = None
        self.provider       = w3_provider
        self.accounts       = accounts
        self.ins_coverage   = None
        self.block_coverage = None
        self.player         = None

    def compile_sol(self, solfile):
        self.solfile = solfile

        compiled_sol = compile_source(
            open('./contracts/{name}'.format(name=self.solfile),'r').read(),
            solc_version="0.4.26",
            output_values=['abi', 'bin', 'opcodes', 'ast']
        )

        with open("compiled_code.json", "w") as file:
            json.dump(compiled_sol, file)

        for name in compiled_sol.keys():
            abi      = compiled_sol[name]['abi']
            bytecode = compiled_sol[name]['bin']
            opcodes   = compiled_sol[name]['opcodes']
            ast      = compiled_sol[name]['ast']
            self.contracts[name.replace('<stdin>:', '')] = Contract(abi, bytecode, opcodes, ast)

        for contract_name in self.contracts.keys():
            for function in self.contracts[contract_name].abi:
                if("name" in function):
                    self.contracts[contract_name].function_records[function['name']] = \
                        FunctionRecord(
                            function['name'],
                            len(function['inputs']), # arguments
                            # len(self.contracts[contract_name].opcodes.split(" ")),
                            # len(function['inputs'])
                        )

        return {'result' : 'Compile done'}

    def get_opcode_from_transaction(self, txn_hash):
        opcodes = []
        raw_trace_list = self.provider.manager.request_blocking("debug_traceTransaction", [txn_hash])
        for item in raw_trace_list.structLogs:
            opcodes += [item['op']]
        return opcodes
    
    def calculate_SC_coverage(self, contract):
        total_SC_opcode   = len(self.contracts[contract].opcodes)
        total_func_opcode = 0
        for k,v in self.contracts[contract].function_records.items():
            total_func_opcode += len(v.opcodes)

        result = round(float(total_func_opcode / total_SC_opcode), 5)
        return result
    
    def update_features(self, contract, function, tx_hash):
        self.contracts[contract].execution_count  += 1
        # Update Function features
        func = self.contracts[contract].function_records[function]
        func.execution_count += 1
        func.opcodes = self.get_opcode_from_transaction(tx_hash.hex())
        func.features['Opcodes'] = func.count_top_50()
        func.features['Call']    = round(float(func.execution_count / self.contracts[contract].execution_count), 5)
        func.features['Coverage'] = round(float(len(func.opcodes) / len(self.contracts[contract].opcodes)), 5)
        self.contracts[contract].function_records[function] = func

        # Update Contract features
        self.contracts[contract].features['Coverage'] = self.calculate_SC_coverage(contract)

    def deploy(self, contract_name):
        bytecode = self.contracts[contract_name].bytecode
        abi      = self.contracts[contract_name].abi
        self.instance       = self.provider.eth.contract(bytecode=bytecode, abi=abi)
        tx_hash             = self.instance.constructor().transact({'from': self.accounts[0]})
        tx_receipt          = self.provider.eth.waitForTransactionReceipt(tx_hash)
        debug(tx_receipt, color=Fore.LIGHTYELLOW_EX)
        self.contracts[contract_name].address = tx_receipt.contractAddress
        self.player         = self.provider.eth.contract(address=tx_receipt.contractAddress, abi=abi)
        debug(f'Deploy contract {contract_name} at {tx_receipt.contractAddress}')
        return {'result' : f'Deploy contract {contract_name} at {tx_receipt.contractAddress}'}

    def checkOracle(self, prev_base, post_base, prev_attack, post_attack):
        is_violate = 0
        if(prev_base + prev_attack < post_base + post_attack):
            is_violate = 1
        return is_violate

    def execute(self, contract, function):
        debug("Execute " + contract + ' -> ' + function, color=Fore.LIGHTGREEN_EX)

        prev_base_balance   = self.provider.eth.getBalance(self.accounts[0])
        prev_attack_balance = self.provider.eth.getBalance(self.accounts[1])

        func_call = self.player.get_function_by_signature(function)
        func_name = function.split('(')[0]
        params    = function.split('(')[1].replace(')', '').split(',')
        
        # try:
        list_param = []

        # Randomize input
        for param in params:
            if('uint' in param):
                # value = random.choice(  [0, 1, 2, 3, random.randint(0, 10e9), random.randint(0, 10e9),random.randint(0, 10e9)])
                value = 0
                list_param += [int(value)]
            elif('int' in param):
                value = random.randint(-10e9, 10e9)
                list_param += [int(value)]
            elif('address' in param):
                list_param += [random.choice(self.accounts)]

        tx_hash = func_call(*list_param).transact({'from': self.accounts[1]})
        # tx_receipt = self.provider.eth.waitForTransactionReceipt(tx_hash)

        post_base_balance   = self.provider.eth.getBalance(self.accounts[0])
        post_attack_balance = self.provider.eth.getBalance(self.accounts[1])
        
        self.update_features(contract, func_name, tx_hash)
        
        Rbugs = self.checkOracle(prev_base_balance, post_base_balance, prev_attack_balance, post_attack_balance)
        Reward_score = self.contracts[contract].calculate_Rmix(alpha=0.7, Rbugs = Rbugs)

        return {
            'SC': json.dumps(self.contracts[contract].features),
            'F':  json.dumps(self.contracts[contract].function_records[func_name].features),
            'Rewards': Reward_score
        }
        
        # except Exception as err:
        #     debug(err, color=Fore.RED)
        #     last_block = self.provider.eth.getBlock('latest')
        #     last_transactions = last_block.transactions[0]
        #     # debug(last_transactions[0].hex(), color=Fore.LIGHTYELLOW_EX)
        #     self.update_features(contract, func_name, last_transactions)

        #     func = self.contracts[contract].function_records[func_name]

        #     if("RETURN"   == func.opcodes[-1]): func.features['Return'] = 1
        #     if("STOP"     == func.opcodes[-1]): func.features['Revert'] = 1
        #     if("INVALID"  == func.opcodes[-1]): func.features['Assert'] = 1

        #     func.freq_exec = round(float(func.execution_count / self.contracts[contract].execution_count), 5)
        #     self.contracts[contract].function_records[func_name] = func
            
        #     debug(func.opcodes[-1], color=Fore.YELLOW)
        #     return {
        #         'SC': json.dumps(self.contracts[contract].features),
        #         'F':  json.dumps(self.contracts[contract].function_records[func_name].features),
        #         'Rewards': -1
        #     }        